
import os
import json
import shutil
from pathlib import Path
from typing import Dict, Any, List

class FileManager:
    def __init__(self, allowed_directories: List[str] = None):
        self.command_map = {
            "read_file": self._read_file,
            "read_multiple_files": self._read_multiple_files,
            "write_file": self._write_file,
            "edit_file": self._edit_file,
            "create_directory": self._create_directory,
            "list_directory": self._list_directory,
            "directory_tree": self._directory_tree,
            "move_file": self._move_file,
            "search_files": self._search_files,
            "get_file_info": self._get_file_info,
            "list_allowed_directories": self._list_allowed_directories
        }
        self.allowed_directories = allowed_directories or [
            str(Path.home()),
            os.getcwd(),
            "/tmp"
        ]

    def execute_command(self, command: str, path: str, **kwargs) -> str:
        """Execute file management commands with validation and error handling."""
        try:
            self._validate_command(command)
            self._validate_path(path)
            
            handler = self.command_map[command]
            result = handler(path, **kwargs)
            return self._format_response(result)
            
        except Exception as e:
            return self._handle_error(e)

    def _validate_command(self, command: str) -> None:
        """Ensure the requested command exists."""
        if command not in self.command_map:
            raise ValueError(f"Invalid command: {command}. Available commands: {list(self.command_map.keys())}")

    def _validate_path(self, path: str) -> None:
        """Check if path is in allowed directories."""
        resolved_path = Path(path).resolve()
        if not any(resolved_path.is_relative_to(allowed) for allowed in self.allowed_directories):
            raise PermissionError(f"Access to path {path} is not allowed")

    def _format_response(self, result: Any) -> str:
        """Format successful response as JSON."""
        return json.dumps({
            "success": True,
            "result": result
        })

    def _handle_error(self, error: Exception) -> str:
        """Format error response as JSON."""
        return json.dumps({
            "success": False,
            "error": f"{type(error).__name__}: {str(error)}"
        })

    # Command implementations
    def _read_file(self, path: str, **_) -> str:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()

    def _read_multiple_files(self, paths: List[str], **_) -> Dict[str, str]:
        return {p: self._read_file(p) for p in paths}

    def _write_file(self, path: str, content: str = "", **_) -> None:
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)

    def _edit_file(self, path: str, line_numbers: List[int] = [], new_content: List[str] = [], **_) -> None:
        with open(path, 'r+', encoding='utf-8') as f:
            lines = f.readlines()
            for num, content in zip(line_numbers, new_content):
                if 1 <= num <= len(lines):
                    lines[num-1] = content + '\n'
            f.seek(0)
            f.writelines(lines)
            f.truncate()

    def _create_directory(self, path: str, **_) -> None:
        Path(path).mkdir(parents=True, exist_ok=True)

    def _list_directory(self, path: str, **_) -> List[Dict]:
        return [{
            "name": entry.name,
            "type": "directory" if entry.is_dir() else "file",
            "size": entry.stat().st_size if entry.is_file() else 0
        } for entry in os.scandir(path)]

    def _directory_tree(self, path: str, **_) -> Dict:
        root = Path(path)
        return {
            "name": root.name,
            "children": [self._directory_tree(child) if child.is_dir() else {"name": child.name}
                        for child in root.iterdir()]
        }

    def _move_file(self, source: str, destination: str, **_) -> None:
        shutil.move(source, destination)

    def _search_files(self, path: str, pattern: str = "*", **_) -> List[str]:
        return [str(p) for p in Path(path).rglob(pattern)]

    def _get_file_info(self, path: str, **_) -> Dict:
        stat = os.stat(path)
        return {
            "path": path,
            "size": stat.st_size,
            "last_modified": stat.st_mtime,
            "created": stat.st_ctime,
            "is_directory": os.path.isdir(path)
        }

    def _list_allowed_directories(self, *_) -> List[str]:
        return self.allowed_directories
        
# Initialize file manager
fm = FileManager()

# Read file contents
print(fm.execute_command("read_file", "/path/to/file.txt"))

# Create new directory
print(fm.execute_command("create_directory", "/path/to/new_dir"))

# Get directory listing
print(fm.execute_command("list_directory", "/path/to/dir"))

# Edit specific lines in a file
print(fm.execute_command("edit_file", "/path/to/file.txt",
                       line_numbers=[1, 3],
                       new_content=["First line", "Third line"]))

# Get allowed directories
print(fm.execute_command("list_allowed_directories", ""))